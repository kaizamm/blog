---
layout: post
title:  linux之虚拟网桥
date:   2018-05-21  
categories: project
tag:
  - linux

---
* content
{:toc}


### 网桥
网桥Bridge是两端口的二层交换设备，用来连接不同网段。网桥的两个端口分别有一条独立的交换信道，不是共享一条背板总线，可隔离冲突域。网桥比集线器（Hub）性能更好，集线器上各端口都是共享同一条背板总线的。后来，网桥被具有更多端口、同时也可隔离冲突域的交换机（Switch）所取代。网桥是一种对帧进行转发的技术，根据MAC分区块，可隔离碰撞。网桥将网络的多个网段在数据链路层连接起来，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器。其工作模式与交换机一样，可理解为交换机是多端口的网桥。<br>

举例感受下：这个是一个2个端口的网桥，网桥流行的时候，一般都是2个端口的网桥，很快就被交换机所替代了，端口1连接LAN1，下面有2个电脑PC1和PC2，端口2连接LAN2，下面有2个电脑，PC3和PC4。

所谓的LAN1和LAN2就是2个物理上独立的2个小的局域网络，和我们所谓的VLAN（所谓一个VLAN就是一个网段）没有任何关系，完全可以理解为，网桥的端口1连接了一个集线器，下面连接了2个电脑，就这么简单，LAN2也是如此，所以，所谓的网桥连接了2个LAN，其实就是网桥连接了两个小的局域网，或者2个集线器而已，电脑是接在集线器下面。

到达网桥的数据帧的路由选择过程取决于发送的LAN(源LAN)和目的地所在的LAN(目的LAN)

1、如果源LAN和目的LAN相同，则丢弃该帧。
2、如果源LAN和目的LAN不同，则转发该帧。
3、如果目的LAN未知，则进行扩散

假设现在PC1 访问PC2，网桥收到这个数据帧以后，一看，源MAC属于LAN1 ，目的MAC也是属于LAN1，立刻丢弃，因为网桥负责的是LAN和LAN之间的通信，至于LAN内部主机通讯，它是不管的，那么PC1和PC2是如何通讯的呢？很简单，因为PC2也会收到这个数据帧，PC1和PC2是用集线器连接起来的，集线器会广播所有的数据帧（因为它没有MAC表格），PC2收到数据帧以后，一看，目的MAC就是自己，所以会进行收包，然后回复数据包，这样PC1和PC2的通讯就建立了，根本和网桥没有关系，也就是说局域网内部通信不通过网桥。

假设现在PC1访问PC3，那么同样的，PC1也会发送数据帧给PC3，这个时候由于PC3在LAN2里面所以，它并不会收到这个数据帧，但是，网桥会收到，它发现，源MAC属于LAN1，目的MAC属于LAN2，这个时候它就会转发这个数据帧，它查看自己的MAC表，发现目的MAC属于LAN2，于是，把这个数据帧通过网桥的网口2转发给PC3，PC3收到以后，一看目的MAC就是自己的MAC，所以也会进行收包，然后回复，回复的过程和刚才的过程相反，也是通过网桥来进行的，这个过程，就是网桥的低层路由过程，其实就是第二层的MAC路由过程。

### 集线器与交换机
交换机(Switch)是一种基于MAC（网卡的硬件地址）识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。·集线器(HUB)是计算机网络中连接多个计算机或其他设备的连接设备，是对网络进行集中管理的最小单元。英文Hub就是中心的意思，像树的主干一样，它是各分支的汇集点。HUB是一个共享设备，主要提供信号放大和中转的功能，它把一个端口接收的所有信号向所有端口分发出去。打个比方一个8口hub， 当端口1上的机器要给端口8上的机器发数据，那这个数据是这样跑的：首先她在端口1上侦听hub上有没有数据在传输，如果没有，端口1就跳出来向hub上喊：“我有数据包要给端口8，请端口8听到后回话” 这个数据被以广播的方式发送到hub上的其余7个口上，每端口都会接到这样的数据包，然后端口2－－－端口7会发一则消息给断口1：“我不是端口8，请你快tmd释放带宽资源” 与此同时端口8会发消息给断口1：“我是端口8，你在找我吗？”端口1收到上述消息后，会和端口8进行确认，然后他们建立传输链接，完成数据转发。等如果端口1在发送寻找断口8的消息后，没有得到相应，那她还会接着发这个消息，直到收到端口8的回答。等端口1和端口8完整数据转发后，假设他们还要进行通讯，那么hub上还会重复以上的过程。由此可见hub的通信方式点点碰撞，一个数据，需要送达所有的端口，这不但增加了数据转发的时间，更要命的是hub往往会给网络带来可怕的广播风暴。 而相同的工作再交换机就不用这么麻烦，假设端口1和端口8从没有通信过，那么开始的时候，他们的工作和hub一样，端口1要在交换机上找端口8，一旦端口8返回确认信息，那再端口1上就会生成1个和端口8的地址对应表，这个表里面有所有和端口1通过信的端口，一旦有了这地址对应表，那在以后端口1要和端口8通讯，就不用这么麻烦，可以直接送达，而且其他的断口也不会知道他们直接正在转发数据，这样不当加快了数据转发时间，而且避免了可怕的广播风暴。

### 系统网桥的配置
要是Linux可以工作在网桥模式，安装网桥工具bridge-utils，运行命令：
```
yum install bridge-utils -y
```
创建网桥br0
```
brctl addbr br0
```
在网桥上添加port
```
brctl addif br0 eth0
```
删除网桥
```
brctl delif br0 eth0
fconfig br0 down
brctl delbr br0
```

### ovs网桥创建
ovs是一个高质量的，多层虚拟交换机(网络分层的层),其目的是让大规模网络自动化可以通过编程扩展，同时仍然支持标准的管理接口和协议：NetFlow. SFlow等，并且它还支持多个物理机的分布式环境。

创建网桥 brcpic
```
#vim /etc/sysconfig/network-scripts/ifcfg-brcpic

DEVICE=brcpic
ONBOOT=yes
TYPE=OVSBridge
DEVICETYPE=ovs
```
启动对应网桥brcpic即可生效

ovs 网桥绑定物理网卡
```
#vim  /etc/sysconfig/network-scripts/ifcfg-eth1

NAME=eth1
DEVICE=eth1
ONBOOT=yes
NETBOOT=yes
BOOTPROTO=static
TYPE=OVSPort
DEFROUTE=yes
IPV4_FAILURE_FATAL=yes
IPV6INIT=no
IPV6_AUTOCONF=no
IPV6_DEFROUTE=no
IPV6_FAILURE_FATAL=no
PEERDNS=yes
PEERROUTES=yes
IPV6_PEERDNS=no
IPV6_PEERROUTES=no
DEVICETYPE=ovs
OVS_BRIDGE=brmgnt
HWADDR=EC:38:8F:7A:EB:8A
```
也可以不修改网卡配置，直接使用命令进行网卡绑定
```
#ovs-vsctl add-port brmgnt eth1
```
ovs 网桥生成有tag的port

Ceph public的Port配置文件，ip netmask网关的值请根据实际环境信息修改

```
#vim /etc/sysconfig/network-scripts/ifcfg-ironic

DEVICE=ironic
ONBOOT=yes
NETBOOT=yes
BOOTPROTO=static
IPADDR=192.168.202.190
NETMASK=255.255.255.0
TYPE=OVSIntPort
OVS_BRIDGE=brmgnt
DEVICETYPE=ovs
OVS_OPTIONS="tag=202"
```
 ovs 网桥绑定无tag的port

 Ceph public的Port配置文件，ip netmask网关的值请根据实际环境信息修改
```
#vim /etc/sysconfig/network-scripts/ifcfg-ceph

DEVICE=ceph
ONBOOT=yes  
NETBOOT=yes  
BOOTPROTO=static
IPADDR=10.127.3.5
NETMASK=255.255.255.0
TYPE=OVSIntPort  
OVS_BRIDGE=brcpic  
```

### linux路由配置
[参考](https://www.cnblogs.com/kevingrace/p/6490627.html)
```
route -n

Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
192.168.1.17    0.0.0.0         255.255.255.255 UH    0      0        0 ppp0
10.1.32.14      0.0.0.0         255.255.255.255 UH    0      0        0 tun0
10.1.32.12      0.0.0.0         255.255.255.255 UH    0      0        0 tun0
10.4.8.2        192.168.9.254   255.255.255.255 UGH   0      0        0 eth0
10.4.9.0        0.0.0.0         255.255.255.0   U     0      0        0 tun0
192.168.9.0     0.0.0.0         255.255.255.0   U     1      0        0 eth0
10.2.0.0        0.0.0.0         255.255.0.0     U     0      0        0 tun0
10.0.0.0        0.0.0.0         255.255.0.0     U     0      0        0 tun0
10.1.0.0        0.0.0.0         255.255.0.0     U     0      0        0 tun0
192.168.0.0     0.0.0.0         255.255.0.0     U     0      0        0 tun0
0.0.0.0         192.168.9.254   0.0.0.0         UG    0      0        0 eth0
```

<img src="{{ '/styles/images/907596-20170302144135110-1552572184.png' | prepend: site.baseurl }}" alt="" width="610" />

#### 主机路由

主机路由是路由选择表中指向单个IP地址或主机名的路由记录。主机路由的Flags字段为H。例如，在下面的示例中，本地主机通过IP地址192.168.1.1的路由器到达IP地址为10.0.0.10的主机。
```
Destination    Gateway       Genmask        Flags     Metric    Ref    Use    Iface
-----------    -------     -------            -----     ------    ---    ---    -----
10.0.0.10     192.168.1.1    255.255.255.255   UH       0    0      0    eth0
```

#### 网络路由
`网络路由是代表主机可以到达的网络`。网络路由的Flags字段为N。例如，在下面的示例中，本地主机将发送到网络192.19.12的数据包转发到IP地址为192.168.1.1的路由器。

```
Destination    Gateway       Genmask      Flags    Metric    Ref     Use    Iface
-----------    -------     -------         -----    -----   ---    ---    -----
192.19.12     192.168.1.1    255.255.255.0      UN      0       0     0    eth0
```

#### 默认路由
当主机不能在路由表中查找到目标主机的IP地址或网络路由时，数据包就被发送到默认路由（默认网关）上。默认路由的Flags字段为G。例如，在下面的示例中，默认路由是IP地址为192.168.1.1的路由器。
```
Destination    Gateway       Genmask    Flags     Metric    Ref    Use    Iface
-----------    -------     ------- -----      ------    ---    ---    -----
default       192.168.1.1     0.0.0.0    UG       0        0     0    eth0
```

#### 配置路由route的命令

设置和查看路由表都可以用 route 命令，设置内核路由表的命令格式是：
```
route  [add|del] [-net|-host] target [netmask Nm] [gw Gw] [[dev] If]
参数解释：
add           添加一条路由规则
del            删除一条路由规则
-net          目的地址是一个网络
-host         目的地址是一个主机
target        目的网络或主机
netmask    目的地址的网络掩码
gw            路由数据包通过的网关
dev           为路由指定的网络接口
```

#### route命令使用举例
```
添加到主机的路由
# route add -host 192.168.1.2 dev eth0:0
# route add -host 10.20.30.148 gw 10.20.30.40

添加到网络的路由
# route add -net 10.20.30.40 netmask 255.255.255.248 eth0
# route add -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41
# route add -net 192.168.1.0/24 eth1

添加默认路由
# route add default gw 192.168.1.1

删除路由
# route del -host 192.168.1.2 dev eth0:0
# route del -host 10.20.30.148 gw 10.20.30.40
# route del -net 10.20.30.40 netmask 255.255.255.248 eth0
# route del -net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41
# route del -net 192.168.1.0/24 eth1
# route del default gw 192.168.1.1                  //route del default   删除所有的默认路由

添加一条默认路由
# route add default gw 10.0.0.1      //默认只在内存中生效
开机自启动可以追加到/etc/rc.local文件里
# echo "route add default gw 10.0.0.1" >>/etc/rc.local

添加一条静态路由
# route add -net 192.168.2.0/24 gw 192.168.2.254
要永久生效的话要这样做：
# echo "any net 192.168.2.0/24 gw 192.168.2.254" >>/etc/sysconfig/static-routes

添加到一台主机的静态路由
# route add -host 192.168.2.2 gw 192.168.2.254
要永久生效的话要这样做：
# echo "any  host 192.168.2.2 gw 192.168.2.254 " >>/etc/sysconfig/static-routes
注：Linux 默认没有这个文件 ，得手动创建一个
```
#### 设置包转发
在Linux中默认的内核配置已经包含了路由功能，但默认并没有在系统启动时启用此功能；
开启Linux的路由功能可以通过调整内核的网络参数来实现，方法如下
```
临时开启路由功能：
# echo 1 > /proc/sys/net/ipv4/ip_forward
或者
# sysctl -w net.ipv4.ip_forward=1
 永久开启路由功能
# vim /etc/sysctl.conf
net.ipv4.ip_forward = 1
# sysctl -p
```
#### 静态路由配置
添加静态路由到路由表的语法如下：
```
ip route [destination_network] [mask] [next-hop_address] administrative_distance]
```
参数解析：
```
ip route         用于创建静态路由的命令。
Destination_network        需要发布到路由表中的网段。
Mask        在这一网络上使用的子网掩码。
Next-hop_address        下一跳路由器的地址。
administrative_distance      默认时，静态路由有一个取值为1 的管理性距离。在这个命令的尾部添加管理权来修改这个默认值。
```

查看路由表除了使用route -n命令外，还可以使用ip route
```
[root@dev ~]# ip route
192.168.1.17 dev ppp0  proto kernel  scope link  src 192.168.1.190
10.1.32.14 dev tun0  scope link
10.1.32.12 dev tun0  scope link
10.4.8.2 via 192.168.9.254 dev eth0  src 192.168.9.200  mtu 1500 advmss 1460
10.4.9.0/24 dev tun0  scope link
192.168.9.0/24 dev eth0  proto kernel  scope link  src 192.168.9.200  metric 1
10.2.0.0/16 dev tun0  scope link
10.0.0.0/16 dev tun0  scope link
10.1.0.0/16 dev tun0  scope link
192.168.0.0/16 dev tun0  scope link
default via 192.168.9.254 dev eth0
```

#### 实例

<img src="{{ '/styles/images/907596-20170302160634454-1203106349.png' | prepend: site.baseurl }}" alt="" width="410" />

如上图所示，使用A主机192.168.1.2能够ping通E主机192.168.4.2，这两台机能够通信。
操作思路：
1）在主机B上设置默认路由下一跳为192.168.2.2，并开启路由转发功能；
2）在主机C上设置2条静态路由，分别去192.168.1.0/24网段的下一跳为192.168.2.1，去192.168.4.0/24网段的下一跳为192.168.3.2，并开启路由转发功能；
3）在主机D上设置默认路由下一跳为192.168.3.1，并开启路由转发功能。

操作记录：
```
1）A主机上操作：ip为192.168.1.2，设置网关为192.168.1.1
# route add default gw 192.168.1.1

2）B主机上操作：第一块网卡为192.168.1.1，第二块网卡为192.168.2.1
# ifconfig eth0 192.168.1.1
# ifconfig eth1 192.168.2.1   //可以在一块网卡上设置两个ip，比如是eth0，eth0:0

B主机设置默认路由，下一跳为192.168.2.2
# route add default gw 192.168.2.2

B主机开启路由转发功能
# echo 1 > /proc/sys/net/ipv4/ip_forward   //临时转发，可以在/etc/sysctl.conf里设置永久转发

3）C主机上操作：第一块网卡为192.168.2.2，第二块网卡为192.168.3.1
# ifconfig eth0 192.168.2.2
# ifconfig eth1 192.168.3.1   //如果就一块网卡，可以设置ifconfig eth0:0 192.168.3.1

C主机设置2条默认路由
# route add -net 192.168.1.0/24 gw 192.168.2.1
# route add -net 192.168.4.0/24 gw 192.168.3.2

C主机开启路由转发功能
# echo 1 > /proc/sys/net/ipv4/ip_forward

4）D主机上操作：第一块网卡为192.168.3.2，第二块网卡为192.168.4.1
# ifconfig eth0 192.168.3.2
# ifconfig eth1 192.168.4.1

D主机设置默认路由，下一跳为192.168.3.1
# route add default gw 192.168.3.1

D主机开启路由转发功能
# echo 1 > /proc/sys/net/ipv4/ip_forward

5）E主机上操作：ip为192.168.4.2，设置网关为192.168.4.1
# route add default gw 192.168.4.1
```
