---
layout: post
published: true
title:  k8s 之 ingress
categories: [ k8s ]
tags: [ ingress ]
---
* content
{:toc}

# 什么是 ingress？

ingress 是 在 service 上面，流量从 ingress 进入，相当于是七层负载。既然是七层负载，可以想到，可以根据 path uri header 这些参数通过路由规则来实现流量分发或是 url 重写。
另外还有个 ssl 卸载的功能。

ingress 分为 controller 和 ingress resource。

controller 有很多，比如：

+  K8s community ingress controller：这个是默认的，nginx 用的 lua 模块，功能虽然多了点，但是 reload 慢，稳定性不是很好。

+ nginx官方出了个 NGINX INGRESS controller： 用的是 nginx 原生的，没有第三方模块，解决了 reload 慢的问题，但是功能比较单一。

+ traefic: 有漂亮的 UI，用的人比较多。

+ kong: 收费。

![详情](/styles/images/ingress-controllers.png)


那么 controller 到底是什么呢？有什么作用？

controller是以 service 形式呈现的。既然是 service，那么它的 type 可以是 NodePort/LoadBalance，因此可以将服务暴露出来，然后外部流量可以从这个端口进入。

这个地方是 Ingress 的流量的入口。

它是个控制器，既然是控制器，故名思议，控制器一般是从某个地方读取配置文件，然后将它生成内部核心程序能认识的配置文件，然后让这个核心程序能够尽量去达到这个状态。

那这个这个核心程序就是 nginx ，配置规则的地方就是 ingress 这个资源，生成的其实是 nginx 的配置文件。然后 nginx 就根据这个配置文件去实现功能。

# 部署 nginx 官方的控制器

部署有两种方式，通过 helm chart 的方式和 manifest 的方式。

有 helm 部署， 那肯定选择用 helm 来部署，简单高效。

```
helm repo add nginx-stable https://helm.nginx.com/stable && helm upgrade
helm install --name my-release nginx-stable/nginx-ingress
```
这个时会安装 configmap/deployment/pod/secret/service/sa/clusterRole/ClusterRoleBinding/crd。

部署完后，检查下各个资源状态是否正常。

这个时候发现个问题：这个时候svc 是 loadBalancer 类型的，externalIP 是 pending 状态。这个时候需要 edit svc，写上这个node 节点的 IP，这样外部就能访问了。

```
spec:
  type: LoadBalancer
  externalIPs:
  - 192.168.0.10
```

为什么要写这个 Node 节点的 IP 呢？还有没有其他方法呢？

当然有，刚才讲了这个地方，目的就是让外部的流量能进来。通过 NodePort 当然是可以的，绑定到这个 Node 的某个端口就通了。我这个地方比较特殊，因为是单节点的，因此service 是 LoadBalance 的也无所谓，因为只有一个节点，相当于是这个 LB 下面只有这一个节点，因此流量全部到了这个节点。如果是多节点的，那就需要一个外部的 lb 了，然后把这些节点全部挂载到这个 lb 下面，然后流量会下发到那个正常的节点的上。扯远了，这个是 service 的功能，本质上一个道理，并没有什么玄乎的。
![](/styles/images/k8s-service-traffic.png)

> 拓展下：这里是 LoadBalncer 类型，这个 externalIPs 是手动加的，如何知道这个地方是加这个字段，而且很明确它的数据类型是列表？
> 可以通过 expalain 来查。
>```
># kubectl explain svc.spec|less
  externalIPs  <[]string>
    externalIPs is a list of IP addresses for which nodes in the cluster will
    also accept traffic for this service. These IPs are not managed by
    Kubernetes. The user is responsible for ensuring that traffic arrives at a
    node with this IP. A common example is external load-balancers that are not
    part of the Kubernetes system.
```

下载官方仓库，里面有 examples，来搭建下：

```
root@ks-allinone:/root/nginx-f5/kubernetes-ingress/examples/complete-example git:(master*) # ls
 cafe-ingress.yaml  cafe-secret.yaml  cafe.yaml  dashboard.png  README.md
```

把 cafe-ingress.yaml/cafe-secret.yaml/cafe.yaml 分别 kubectl apply -f 应用下
看下 ingress：
```
  spec:
    rules:
    - host: cafe.example.com
      http:
        paths:
        - backend:
            serviceName: tea-svc
            servicePort: 80
          path: /tea
        - backend:
            serviceName: coffee-svc
            servicePort: 80
          path: /coffee
    tls:
    - hosts:
      - cafe.example.com
      secretName: cafe-secret
```
可以看到rule：

1. 匹配的是 http 流量。

2. path 为/tea 的到 tea-svc这个服务。path 为/coffee 的到 coffe-svc这个服务。
这两个服务是后端，真正的 webservice 服务。且指定了 service 的 port。

3. host是 cafe.example.com。这个需要注意，这个 host 是 request 请求 header 的 host。如果没有指定 request，那么就是访问时url 中的域名。

另外还可以定义 rewrite或是 app-root，如：
```
metadata:
  annotations:
    nginx.ingress.kubernetes.io/app-root: /app1
```

现在可以访问：
```
root@ks-allinone:/root/nginx-f5/kubernetes-ingress/examples/complete-example git:(master*) #   kubectl get svc
my-release-nginx-ingress   LoadBalancer   10.233.41.169   10.160.7.101   80:31116/TCP,443:31165/TCP   17h
root@ks-allinone:/root # IC_HTTPS_PORT=31165
root@ks-allinone:/root # IC_IP=10.160.7.101
curl --resolve cafe.example.com:$IC_HTTPS_PORT:$IC_IP https://cafe.example.com:$IC_HTTPS_PORT/coffee --insecure
```

>注意 curl 的使用，--resolve 参数是将 cafe.example.com:$IC_HTTPS_PORT指定访问到$IC_IP 。ingress 在 url 的 host 需要匹配这个 cafe.example.com 这个域名，二者相对应，疑问：如果直接用 ip 访问，而修改 header中的 host 是否也可以？
>```
curl -H "Host:cafe.example.com" https://10.160.7.101:31165/coffee -k
Server address: 10.233.100.207:8080
Server name: coffee-7c45f487fd-7khz7
Date: 20/May/2020:01:45:33 +0000
URI: /coffee
Request ID: 9261cf72df3577256453eeb0f5546a2e
```
说明也是可以的。说明 ingress 中的 host 只是匹配请求的 host，当没有明确指定 host 时，它与 域名保持一致。
控制器默认暴露两个端口 80/443，目前也仅支持这两个端口。


# 问题：如何指定哪个 Ingress 用哪个控制器？

这是多个控制器的问题。

1.18之后改用了`IngressClass`和 `IngressClassName`。
1.18之前：
如果要让 ingress资源指定 controller，需在在定义这个 ingress 时在 annotiations 里面指定`kubernetes.io/ingress.class`。

这个 annotations 的value 如何指定呢？

这个值并不是固定的，而是在 controller  deployment 的启动参数里面会有个 --ingress-class=xxx ，如果没有设置就要设置，否则会出现所有的控制器全部会监测到这个ingress，并生成自己的配置文件：

```
# kubectl edit ing bookinfo-ingress -n pj-demo
      kubernetes.io/ingress.class: nginxnc

# kubectl edit deploy my-release-nginx-ingress -o yaml
    spec:
      containers:
      - args:
        - -ingress-class=nginxnc
```
